"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _ClockinDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    clockin_time: str


class ClockinDict(_ClockinDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    clockout_time: typing.Optional[str]
    user_id: typing.Optional[int]


class TClockin(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: Unique identifier
        clockin_time: The clockin_time of the Clockin.
        clockout_time: The clockout_time of the Clockin.
        user_id: The user_id of the Clockin.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    clockin_time: 'sqlalchemy.Column[str]'
    clockout_time: 'sqlalchemy.Column[typing.Optional[str]]'
    user_id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, clockin_time: str, id: typing.Optional[int] = None, clockout_time: typing.Optional[str] = None, user_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: Unique identifier
            clockin_time: The clockin_time of the Clockin.
            clockout_time: The clockout_time of the Clockin.
            user_id: The user_id of the Clockin.

        """
        ...

    @classmethod
    def from_dict(cls, clockin_time: str, id: typing.Optional[int] = None, clockout_time: typing.Optional[str] = None, user_id: typing.Optional[int] = None) -> "TClockin":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier
            clockin_time: The clockin_time of the Clockin.
            clockout_time: The clockout_time of the Clockin.
            user_id: The user_id of the Clockin.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TClockin":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> ClockinDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Clockin: typing.Type[TClockin] = models.Clockin  # type: ignore


class _CompanyDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class CompanyDict(_CompanyDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    about: str
    phone: str
    address_street: str
    city: str
    state: str
    zip_code: str
    img_url: str
    private: bool


class TCompany(typing.Protocol):
    """
    SQLAlchemy model protocol.

    A grouping of multiple departments, users, and events.

    Attrs:
        id: Unique identifier
        name: The name of the company.
        about: The company's about us.
        phone: organization phone
        address_street: The street address of the company.
        city: The city in which the company is located.
        state: state
        zip_code: zipCode
        img_url: Represents the url of the company's image.
        private: Whether the company's events are queryable.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    about: 'sqlalchemy.Column[str]'
    phone: 'sqlalchemy.Column[str]'
    address_street: 'sqlalchemy.Column[str]'
    city: 'sqlalchemy.Column[str]'
    state: 'sqlalchemy.Column[str]'
    zip_code: 'sqlalchemy.Column[str]'
    img_url: 'sqlalchemy.Column[str]'
    private: 'sqlalchemy.Column[bool]'

    def __init__(self, name: str, id: typing.Optional[int] = None, about: str = "", phone: str = "", address_street: str = "", city: str = "", state: str = "", zip_code: str = "", img_url: str = "", private: bool = False) -> None:
        """
        Construct.

        Args:
            id: Unique identifier
            name: The name of the company.
            about: The company's about us.
            phone: organization phone
            address_street: The street address of the company.
            city: The city in which the company is located.
            state: state
            zip_code: zipCode
            img_url: Represents the url of the company's image.
            private: Whether the company's events are queryable.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None, about: str = "", phone: str = "", address_street: str = "", city: str = "", state: str = "", zip_code: str = "", img_url: str = "", private: bool = False) -> "TCompany":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier
            name: The name of the company.
            about: The company's about us.
            phone: organization phone
            address_street: The street address of the company.
            city: The city in which the company is located.
            state: state
            zip_code: zipCode
            img_url: Represents the url of the company's image.
            private: Whether the company's events are queryable.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TCompany":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> CompanyDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Company: typing.Type[TCompany] = models.Company  # type: ignore


class _DepartmentDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class DepartmentDict(_DepartmentDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    manager_id: typing.Optional[int]
    company_id: typing.Optional[int]


class TDepartment(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Subdivisions of companies.

    Attrs:
        id: The id of the department.
        name: Block of text containing the name of the department.
        manager_id: An id representing the ID of the department manager.
        company_id: The id representing the company the department is in.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    manager_id: 'sqlalchemy.Column[typing.Optional[int]]'
    company_id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, name: str, id: typing.Optional[int] = None, manager_id: typing.Optional[int] = None, company_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the department.
            name: Block of text containing the name of the department.
            manager_id: An id representing the ID of the department manager.
            company_id: The id representing the company the department is in.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None, manager_id: typing.Optional[int] = None, company_id: typing.Optional[int] = None) -> "TDepartment":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the department.
            name: Block of text containing the name of the department.
            manager_id: An id representing the ID of the department manager.
            company_id: The id representing the company the department is in.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TDepartment":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> DepartmentDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Department: typing.Type[TDepartment] = models.Department  # type: ignore


class _EventDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str
    agreed_price: float
    start_datetime: str
    package_id: int
    questions: typing.Any


class EventDict(_EventDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    end_datetime: str
    company_id: typing.Optional[int]
    employee_id: typing.Optional[int]


class TEvent(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Represents a type of event that can be created.

    Attrs:
        id: The identifier for the event.
        name: name
        description: Block of text describing the event.
        agreed_price: The agreed upon price.
        start_datetime: The start datetime.
        end_datetime: The end datetime.
        package_id: The ID of the package associated with this event.
        company_id: The ID of the company associated to the event.
        employee_id: The ID of the employee servicing the event.
        questions: The questions to include in the event form.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    description: 'sqlalchemy.Column[str]'
    agreed_price: 'sqlalchemy.Column[float]'
    start_datetime: 'sqlalchemy.Column[str]'
    end_datetime: 'sqlalchemy.Column[str]'
    package_id: 'sqlalchemy.Column[int]'
    company_id: 'sqlalchemy.Column[typing.Optional[int]]'
    employee_id: 'sqlalchemy.Column[typing.Optional[int]]'
    questions: 'sqlalchemy.Column[typing.Any]'

    def __init__(self, name: str, description: str, agreed_price: float, start_datetime: str, package_id: int, questions: typing.Any, id: typing.Optional[int] = None, end_datetime: str = "", company_id: typing.Optional[int] = None, employee_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The identifier for the event.
            name: name
            description: Block of text describing the event.
            agreed_price: The agreed upon price.
            start_datetime: The start datetime.
            end_datetime: The end datetime.
            package_id: The ID of the package associated with this event.
            company_id: The ID of the company associated to the event.
            employee_id: The ID of the employee servicing the event.
            questions: The questions to include in the event form.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, description: str, agreed_price: float, start_datetime: str, package_id: int, questions: typing.Any, id: typing.Optional[int] = None, end_datetime: str = "", company_id: typing.Optional[int] = None, employee_id: typing.Optional[int] = None) -> "TEvent":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The identifier for the event.
            name: name
            description: Block of text describing the event.
            agreed_price: The agreed upon price.
            start_datetime: The start datetime.
            end_datetime: The end datetime.
            package_id: The ID of the package associated with this event.
            company_id: The ID of the company associated to the event.
            employee_id: The ID of the employee servicing the event.
            questions: The questions to include in the event form.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TEvent":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> EventDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Event: typing.Type[TEvent] = models.Event  # type: ignore


class _PackageDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str


class PackageDict(_PackageDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    img_url: str
    price: float
    company_id: typing.Optional[int]
    questions: typing.Any


class TPackage(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Represents a type of event that can be created.

    Attrs:
        id: The identifier for the role.
        name: name
        description: Block of text describing the role.
        img_url: The url to display the image tag.
        price: The price of the package, in USD.
        company_id: The ID of the company created by.
        questions: The questions to include in the event form.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    description: 'sqlalchemy.Column[str]'
    img_url: 'sqlalchemy.Column[str]'
    price: 'sqlalchemy.Column[float]'
    company_id: 'sqlalchemy.Column[typing.Optional[int]]'
    questions: 'sqlalchemy.Column[typing.Any]'

    def __init__(self, name: str, description: str, id: typing.Optional[int] = None, img_url: str = "", price: float = 0, company_id: typing.Optional[int] = None, questions: typing.Optional[typing.Any] = None) -> None:
        """
        Construct.

        Args:
            id: The identifier for the role.
            name: name
            description: Block of text describing the role.
            img_url: The url to display the image tag.
            price: The price of the package, in USD.
            company_id: The ID of the company created by.
            questions: The questions to include in the event form.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, description: str, id: typing.Optional[int] = None, img_url: str = "", price: float = 0, company_id: typing.Optional[int] = None, questions: typing.Optional[typing.Any] = None) -> "TPackage":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The identifier for the role.
            name: name
            description: Block of text describing the role.
            img_url: The url to display the image tag.
            price: The price of the package, in USD.
            company_id: The ID of the company created by.
            questions: The questions to include in the event form.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TPackage":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> PackageDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Package: typing.Type[TPackage] = models.Package  # type: ignore


class _RoleDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    permissions: str


class RoleDict(_RoleDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    description: typing.Optional[str]


class TRole(typing.Protocol):
    """
    SQLAlchemy model protocol.

    A single role.

    Attrs:
        id: The identifier for the role.
        name: name
        description: Block of text describing the role.
        permissions: Permissions for role

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    description: 'sqlalchemy.Column[typing.Optional[str]]'
    permissions: 'sqlalchemy.Column[str]'

    def __init__(self, name: str, permissions: str, id: typing.Optional[int] = None, description: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The identifier for the role.
            name: name
            description: Block of text describing the role.
            permissions: Permissions for role

        """
        ...

    @classmethod
    def from_dict(cls, name: str, permissions: str, id: typing.Optional[int] = None, description: typing.Optional[str] = None) -> "TRole":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The identifier for the role.
            name: name
            description: Block of text describing the role.
            permissions: Permissions for role

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TRole":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> RoleDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Role: typing.Type[TRole] = models.Role  # type: ignore


class _UserDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    email: str


class UserDict(_UserDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    password: str
    first_name: str
    last_name: str
    pay_rate: float
    department_id: typing.Optional[int]
    role: typing.Optional["RoleDict"]
    role_id: typing.Optional[int]


class TUser(typing.Protocol):
    """
    SQLAlchemy model protocol.

    A single user.

    Attrs:
        id: A unique identifier for a user.
        email: email
        password: The password of the User.
        first_name: The user's first name.
        last_name: The user's last name.
        pay_rate: The user's pay rate.
        department_id: The user's department id.
        role: The role of the User.
        role_id: The user's role id.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    email: 'sqlalchemy.Column[str]'
    password: 'sqlalchemy.Column[str]'
    first_name: 'sqlalchemy.Column[str]'
    last_name: 'sqlalchemy.Column[str]'
    pay_rate: 'sqlalchemy.Column[float]'
    department_id: 'sqlalchemy.Column[typing.Optional[int]]'
    role: 'sqlalchemy.Column[typing.Optional["TRole"]]'
    role_id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, email: str, id: typing.Optional[int] = None, password: str = "", first_name: str = "", last_name: str = "", pay_rate: float = 0, department_id: typing.Optional[int] = None, role: typing.Optional["TRole"] = None, role_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: A unique identifier for a user.
            email: email
            password: The password of the User.
            first_name: The user's first name.
            last_name: The user's last name.
            pay_rate: The user's pay rate.
            department_id: The user's department id.
            role: The role of the User.
            role_id: The user's role id.

        """
        ...

    @classmethod
    def from_dict(cls, email: str, id: typing.Optional[int] = None, password: str = "", first_name: str = "", last_name: str = "", pay_rate: float = 0, department_id: typing.Optional[int] = None, role: typing.Optional["RoleDict"] = None, role_id: typing.Optional[int] = None) -> "TUser":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: A unique identifier for a user.
            email: email
            password: The password of the User.
            first_name: The user's first name.
            last_name: The user's last name.
            pay_rate: The user's pay rate.
            department_id: The user's department id.
            role: The role of the User.
            role_id: The user's role id.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TUser":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> UserDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


User: typing.Type[TUser] = models.User  # type: ignore
